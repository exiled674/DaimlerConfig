@page "/"

@inject DaimlerConfig.Components.Fassade.Fassade Fassade

@using DaimlerConfig.Services
@inject SignalRService SignalRService
@inject NavigationManager Navigation
@inject NavigationStateService NavState

@using CommunityToolkit.Maui.Storage;
@using System.Text.Json
@using System.IO
@using System.Text
@using ClosedXML.Excel
@using DaimlerConfig.Components.Export
@using Microsoft.Maui.Storage
@inject DirtyManagerService DirtyManagerService
@using DaimlerConfig.Components.Models

@using MudBlazor
@inject IDialogService DialogService


<!-- Navbar -->
<MudAppBar Elevation="2" Color="Color.Primary" Class="navbar-aligned">
    <MudText Typo="Typo.h6" Class="ml-0">Project Manager</MudText>
    <MudSpacer />
    <MudIconButton Icon="@Icons.Material.Filled.Settings"
                   Color="Color.Inherit"
                   Size="Size.Medium"
                   OnClick="OpenSettings"
                   Class="settings-aligned" />
</MudAppBar>

@if (ShowSettings)
{
    <Settings OnClosing="CLoseSetting" />
}

<!-- Main Content -->
<div class="ProjectManager container-fluid px-4">
    <!-- div with search and sort-->
    <div class="projects">
        <div class="d-flex align-items-end gap-3 mb-4 pt-3">
            <div class="flex-grow-1">
                <MudTextField @bind-Value="searchText"
                              @bind-Value:after="UpdateFilteredLines"
                              Placeholder="Search projects..."
                              Adornment="Adornment.Start"
                              AdornmentIcon="@Icons.Material.Filled.Search"
                              Immediate="true"
                              Variant="Variant.Outlined"
                              Margin="Margin.Normal"
                              Class="flex-grow-1 search-field-enhanced"
                              Style="background: white; border-radius: 12px;" />
            </div>

            <!-- Sort Dropdown -->
            <div style="width: auto">
                <MudSelect T="string"
                           Value="selectedSort"
                           ValueChanged="OnSortChanged"
                           Variant="Variant.Outlined"
                           Dense="true"
                           Margin="Margin.Normal"
                           FullWidth="true"
                           AnchorOrigin="Origin.BottomCenter"
                           Class="sort-dropdown-enhanced"
                           Style="background: white; border-radius: 12px;">
                    <MudSelectItem Value="@("date")">
                        <div class="d-flex align-items-center">
                            <MudIcon Icon="@Icons.Material.Filled.DateRange" Size="Size.Small" Class="me-2" />
                            Sorted by date descending
                        </div>
                    </MudSelectItem>
                    <MudSelectItem Value="@("name")">
                        <div class="d-flex align-items-center">
                            <MudIcon Icon="@Icons.Material.Filled.SortByAlpha" Size="Size.Small" Class="me-2" />
                            Sorted by name ascending
                        </div>
                    </MudSelectItem>
                </MudSelect>
            </div>
        </div>
    </div>

    <!-- Lines List -->
    @if (FilteredLines?.Any() == true)
    {
        @foreach (var line in FilteredLines)
        {
            <MudCard Class="my-3 hover-lift hover-highlight"
                     Elevation="3"
                     Style="border-radius: 12px; margin: 0 0 20px 0; border: 1px solid rgba(0,0,0,0.08);">
                <!-- Editing Line -->
                @if (EditingLines.Contains(line))
                {
                    <MudGrid AlignItems="Center" Class="pa-5">
                        <MudItem xs="10">
                            <MudTextField T="string"
                                          @bind-Value="line.lineName"
                                          Placeholder="Line name"
                                          Variant="Variant.Outlined"
                                          Margin="Margin.Dense"
                                          Dense="true"
                                          Immediate="true"
                                          FullWidth="true"
                                          Error="@isDuplicateName"
                                          ErrorText="The name already exists."
                                          @onblur="@(e => ConfirmEdit(line))"
                                          @onkeydown="@(e => OnEditKeyDown(e, line))"
                                          @onkeyup="@(e => OnEditKeyUp(e, line))"
                                          AutoFocus="true" />
                        </MudItem>
                        <MudItem xs="2" Class="d-flex justify-end">
                            <MudIconButton Icon="@Icons.Material.Filled.Close"
                                           Color="Color.Secondary"
                                           Size="Size.Small"
                                           OnClick="() => CancelEdit(line)"
                                           Title="Cancel" />
                        </MudItem>
                    </MudGrid>
                }
                // Normal Line Display
                else
                {
                    <MudGrid AlignItems="Center" Class="pa-4">
                        <MudItem xs="10" Class="cursor-pointer" @onclick="@(() => NavigateToLine(line.lineName))">
                            <div class="d-flex flex-column align-items-start ma-0 pa-0">
                                <MudText Typo="Typo.subtitle1" Class="font-weight-medium ma-0 pa-0">
                                    @line.lineName
                                </MudText>
                                <MudChip T="string"
                                         Class="mt-1 ma-0" Size="Size.Small"
                                         Color="Color.Secondary"
                                         Text="@($"Modified: {line.lastModified:dd.MM.yyyy}")" />
                            </div>
                        </MudItem>

                        <MudItem xs="2" Class="d-flex justify-end">
                            <div @onclick:stopPropagation>
                                <MudMenu Icon="@Icons.Material.Filled.MoreVert"
                                         Size="Size.Small"
                                         Dense="true"
                                         AnchorOrigin="Origin.BottomRight"
                                         TransformOrigin="Origin.TopRight">
                                    <MudMenuItem OnClick="@(() => StartEditing(line))"
                                                 Icon="@Icons.Material.Filled.Edit">
                                        Edit
                                    </MudMenuItem>
                                    <MudMenuItem OnClick="@(() => DeleteLine(line))"
                                                 Icon="@Icons.Material.Filled.Delete"
                                                 IconColor="Color.Error">
                                        Delete
                                    </MudMenuItem>
                                    <MudDivider />
                                    <MudMenuItem OnClick="@(() => ExportToExcel(line))"
                                                 Icon="@Icons.Material.Filled.FileDownload">
                                        Export to Excel
                                    </MudMenuItem>
                                    <MudMenuItem OnClick="@(() => ExportToJson(line))"
                                                 Icon="@Icons.Material.Filled.FileDownload">
                                        Export to Json
                                    </MudMenuItem>
                                </MudMenu>
                            </div>
                        </MudItem>
                    </MudGrid>
                }
            </MudCard>
        }
    }
    else
    {
        <p class="text-muted">Keine Lines gefunden.</p>
    }


    <div>
        <MudFab Icon="@Icons.Material.Filled.Add"
                Color="Color.Primary"
                Size="Size.Large"
                Style="position:fixed;bottom:32px;right:32px;z-index:2000;border-radius:32px;"
                Onclick="OpenDialogAsync"
                Label="Create new Project"
                Class="fab-enhanced px-4 py-2" />
    </div>
</div>


<style>
    .hover-lift {
        transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }

        .hover-lift:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15) !important;
        }

    .cursor-pointer {
        cursor: pointer;
    }

    .mud-fab-extended {
        border-radius: 28px !important;
    }

    .hover-highlight {
        transition: background-color 0.2s ease;
    }

        .hover-highlight:hover {
            background-color: color-mix(in srgb, var(--mud-palette-primary) 10%, white);
            cursor: pointer;
        }



    .search-field-enhanced {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06) !important;
        transition: box-shadow 0.2s ease-in-out !important;
    }

        .search-field-enhanced:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.15), 0 4px 8px rgba(0,0,0,0.1) !important;
        }

        .search-field-enhanced .mud-input-outlined {
            background: white !important;
            border-radius: 12px !important;
        }


    .sort-dropdown-enhanced {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06) !important;
        transition: box-shadow 0.2s ease-in-out !important;
    }

        .sort-dropdown-enhanced:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.15), 0 4px 8px rgba(0,0,0,0.1) !important;
        }


    .fab-enhanced {
        box-shadow: 0 12px 32px rgba(25, 118, 210, 0.4), 0 6px 16px rgba(0,0,0,0.15) !important;
        transition: all 0.3s ease-in-out !important;
        transform: translateY(0px);
    }


        .fab-enhanced:hover {
            box-shadow: 0 16px 40px rgba(25, 118, 210, 0.5), 0 8px 20px rgba(0,0,0,0.2) !important;
            transform: translateY(-4px) !important;
        }

    .navbar-aligned {
        padding-left: 0px !important;
        padding-right: 24px !important;
    }

    .settings-aligned {
        position: absolute;
        right: 9px;
        padding-left: 0px !important;
        padding-right: 0px !important;
    }
</style>


@code {
    private List<Line> AllLines = new();
    private List<Line> FilteredLines = new();
    private HashSet<Line> EditingLines = new();
    private string searchText = "";
    private string selectedSort = "date";
    private bool isDuplicateName = false;
    private bool ShowSettings = false;
    private Dictionary<Line, bool> pendingConfirmation = new();

    protected override async Task OnInitializedAsync()
    {
        NavState.SetCurrentRoute("/");

        // SignalR Event Handler registrieren
        SignalRService.RegisterResponseHandler(async (string message) => await HandleSignalRMessage(message));
        await SignalRService.StartConnectionAsync();

        // Initiales Laden der Daten
        await LoadAllLines();
        UpdateFilteredLines();
    }

    private async Task LoadAllLines()
    {
        var result = await Fassade.GetAllLinesAsync();
        AllLines = result.ToList();
    }

    private async Task HandleSignalRMessage(string message)
    {
        await InvokeAsync(async () =>
        {
            var parts = message.Split(';');
            if (parts.Length < 2) return;

            var lineID = int.Parse(parts[1]);

            switch (parts[0])
            {
                case "LineAdded":
                    await HandleLineAdded(lineID);
                    break;
                case "LineUpdated":
                    await HandleLineUpdated(lineID);
                    break;
                case "LineDeleted":
                    HandleLineDeleted(lineID);
                    break;
            }
        });
    }

    private async Task HandleLineAdded(int lineID)
    {
        if (AllLines.Any(l => l.lineID == lineID)) return;

        var line = await Fassade.GetLine(lineID);
        if (line != null)
        {
            AllLines.Add(line);
            UpdateFilteredLines();
            StateHasChanged();
        }
    }

    private async Task HandleLineUpdated(int lineID)
    {
        var existingLine = AllLines.FirstOrDefault(l => l.lineID == lineID);
        if (existingLine == null) return;

        var updatedLine = await Fassade.GetLine(lineID);
        if (updatedLine != null)
        {
            var index = AllLines.IndexOf(existingLine);
            AllLines[index] = updatedLine;
            UpdateFilteredLines();
            StateHasChanged();
        }
    }

    private void HandleLineDeleted(int lineID)
    {
        var lineToRemove = AllLines.FirstOrDefault(l => l.lineID == lineID);
        if (lineToRemove != null)
        {
            AllLines.Remove(lineToRemove);
            EditingLines.Remove(lineToRemove);
            pendingConfirmation.Remove(lineToRemove);
            UpdateFilteredLines();
            StateHasChanged();
        }
    }

    private void OnSortChanged(string newSortValue)
    {
        selectedSort = newSortValue;
        UpdateFilteredLines();
    }

    // Verbesserte Keyboard-Event-Handler
    private async Task OnEditKeyDown(KeyboardEventArgs e, Line line)
    {
        if (e.Key == "Enter")
        {
            // Verhindere mehrfache Ausführung
            if (!pendingConfirmation.GetValueOrDefault(line, false))
            {
                pendingConfirmation[line] = true;
                await ConfirmEdit(line);
            }
        }
        else if (e.Key == "Escape")
        {
            CancelEdit(line);
        }
    }

    private void OnEditKeyUp(KeyboardEventArgs e, Line line)
    {
        // Reset pending confirmation nach KeyUp
        if (e.Key == "Enter")
        {
            pendingConfirmation[line] = false;
        }
    }

    private void UpdateFilteredLines()
    {
        // Erst filtern nach Suchtext
        var filtered = AllLines.Where(line =>
            string.IsNullOrEmpty(searchText) ||
            line.lineName.StartsWith(searchText, StringComparison.OrdinalIgnoreCase));

        // Dann sortieren
        FilteredLines = selectedSort switch
        {
            "name" => filtered.OrderBy(l => l.lineName).ToList(),
            "date" => filtered.OrderByDescending(l => l.lastModified).ToList(),
            _ => filtered.OrderByDescending(l => l.lastModified).ToList()
        };

        StateHasChanged();
    }

    private void StartEditing(Line line)
    {
        EditingLines.Add(line);
        pendingConfirmation[line] = false; // Reset pending status
    }

    private async Task DeleteLine(Line line)
    {
        await Fassade.DeleteLine(line);
        AllLines.Remove(line);
        EditingLines.Remove(line);
        pendingConfirmation.Remove(line);
        await SignalRService.SendMessageToServer($"LineDeleted;{line.lineID}");
        UpdateFilteredLines();
    }

    private void CreateNewLine()
    {
        var newLine = new Line
            {
                lineName = "Enter a name",
                lastModified = DateTime.Now,
                lineID = 0 // Kennzeichnet neue Line
            };

        AllLines.Insert(0, newLine);
        EditingLines.Add(newLine);
        pendingConfirmation[newLine] = false; // Initialize pending status
        UpdateFilteredLines();
    }

    private async Task ConfirmEdit(Line line)
    {
        var newName = line.lineName?.Trim();

        // Validierung
        if (string.IsNullOrEmpty(newName) || newName == "Enter a name")
        {
            isDuplicateName = false;
            pendingConfirmation[line] = false;
            return;
        }

        // Prüfung auf doppelte Namen (außer bei sich selbst)
        isDuplicateName = AllLines.Any(l => l != line &&
            string.Equals(l.lineName, newName, StringComparison.OrdinalIgnoreCase));

        if (isDuplicateName)
        {
            pendingConfirmation[line] = false;
            StateHasChanged();
            return;
        }

        // Speichern
        line.lineName = newName;
        line.lastModified = DateTime.Now;

        try
        {
            if (line.lineID == 0) // Neue Line
            {
                await Fassade.AddLine(line);
                var savedLine = await Fassade.GetLineByName(line.lineName);
                if (savedLine != null)
                {
                    // Ersetze die temporäre Line mit der gespeicherten
                    var index = AllLines.IndexOf(line);
                    AllLines[index] = savedLine;
                    EditingLines.Remove(line);
                    pendingConfirmation.Remove(line);

                    await SignalRService.SendMessageToServer($"LineAdded;{savedLine.lineID}");
                }
            }
            else // Bestehende Line aktualisieren
            {
                await Fassade.UpdateLine(line);
                await SignalRService.SendMessageToServer($"LineUpdated;{line.lineID}");
                EditingLines.Remove(line);
                pendingConfirmation.Remove(line);
            }

            isDuplicateName = false;
            UpdateFilteredLines();
        }
        catch (Exception ex)
        {
            // Fehlerbehandlung - hier könntest du eine Benachrichtigung anzeigen
            Console.WriteLine($"Fehler beim Speichern: {ex.Message}");
            pendingConfirmation[line] = false;
        }
    }

    private void CancelEdit(Line line)
    {
        if (line.lineID == 0) // Neue Line wurde abgebrochen
        {
            AllLines.Remove(line);
        }
        else
        {
            // Bei bestehenden Lines: Änderungen zurücksetzen
            // Hier könntest du die ursprünglichen Werte wiederherstellen
        }

        EditingLines.Remove(line);
        pendingConfirmation.Remove(line);
        isDuplicateName = false;
        UpdateFilteredLines();
    }

    private void NavigateToLine(string lineName)
    {
        Navigation.NavigateTo($"/line/{Uri.EscapeDataString(lineName)}");
    }

    private async Task ExportToExcel(Line line)
    {
        try
        {
            // Vorbereiten der Daten
            var tools = new List<Tool>();
            var operations = new List<Operation>();
            var stations = await Fassade.GetStationsFromLine(line.lineID);

            foreach (var station in stations)
            {
                tools.AddRange(await Fassade.GetToolsFromStation(station.stationID));
            }

            foreach (var tool in tools)
            {
                operations.AddRange(await Fassade.GetOperationsFromTool(tool.toolID));
            }

            var stationTypes = await Fassade.StationTypeRepository.GetAll();
            var toolTypes = await Fassade.ToolTypeRepository.GetAll();
            var toolClasses = await Fassade.ToolClassRepository.GetAll();

            // Excel-Datei erstellen und speichern
            using var stream = new MemoryStream();
            using (var workbook = new XLWorkbook())
            {
                Fassade.ExcelExport.Export(stream, line, stations.ToArray(), tools.ToArray(),
                    stationTypes.ToArray(), toolTypes.ToArray(), toolClasses.ToArray());
            }

            var fileName = $"ExcelExport-{line.lineName ?? "line"}_{DateTime.Now:yyyyMMdd}.xlsx";
            var result = await FileSaver.Default.SaveAsync(fileName, stream, new CancellationToken());

            if (result.IsSuccessful)
            {
                await Application.Current.MainPage.DisplayAlert("Success", "The file was saved successfully.", "OK");
            }
        }
        catch (Exception ex)
        {
            await Application.Current.MainPage.DisplayAlert("Error",
                "An error occurred while saving the file: " + ex.Message, "OK");
        }
    }

    private async Task ExportToJson(Line line)
    {
        try
        {
            var json = await Fassade.Export(line);
            var bytes = Encoding.UTF8.GetBytes(json);
            var fileName = $"JsonExport-{line.lineName ?? "line"}_{DateTime.Now:yyyyMMdd}.json";

            var result = await FileSaver.Default.SaveAsync(fileName, new MemoryStream(bytes), new CancellationToken());

            if (result.IsSuccessful)
            {
                await Application.Current.MainPage.DisplayAlert("Success", "The file was saved successfully.", "OK");
            }
        }
        catch (Exception ex)
        {
            await Application.Current.MainPage.DisplayAlert("Error",
                "An error occurred while saving the file: " + ex.Message, "OK");
        }
    }

    #region Settings
    private void OpenSettings()
    {
        if (ShowSettings) return;
        ShowSettings = true;
    }

    private void CLoseSetting()
    {
        ShowSettings = false;
    }
    #endregion


    #region popup
    private async Task OpenDialogAsync()
    {
        var dialog = DialogService.Show<CreateProjectPopup>("Neues Projekt");
        var resultReference = await dialog.Result;
        var result = resultReference as DialogResult;

        if (result != null && result.Canceled == false)
        {
            var name = result.Data?.ToString();
            Console.WriteLine($"Projektname: {name}");
        }
    }
    #endregion
}
