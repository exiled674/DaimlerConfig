@page "/line/{lineName}"

@using DaimlerConfig.Services
@inject SignalRService SignalRService
@inject DirtyManagerService DirtyManagerService
@inject AppLifecycleService LifecycleService

@inject DaimlerConfig.Components.Fassade.Fassade Fassade

@using DaimlerConfig.Components.Models
@using Microsoft.JSInterop
@inject IJSRuntime JS;
<script src="https://cdnjs.cloudflare.com/ajax/libs/interact.js/1.10.19/interact.min.js"></script>

<body>
    <!-- Navbar -->
    <nav class="navbar fixed-top bg-white border-bottom">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h2">Project: @line?.lineName</span>
        </div>
    </nav>

    <div class="d-flex sidebar bg-white">
        <!-- Sidebar -->
        <aside id="sidebar" class="@SidebarClass border-end">
            <ul class="sidebar-nav p-0" id="stationsContainer">
                <li class="sidebar-item">
                    <a href="/" class="sidebar-link">
                        <span>Home</span>
                    </a>
                </li>
                <li class="sidebar-header">
                    Stations
                </li>

                @foreach (var station in stations)
                {
                    <li class="sidebar-item draggable" draggable="true" data-station-id="@station.stationID">
                        <a class="sidebar-link clickable @(selectedStation?.stationID == station.stationID ? "active stationSelected" : "")"
                           @onclick="() => { SelectStation(station); ToggleStationFormular(false); }">
                            <Badge colour="@BadgeColor" />
                            <span>@station.assemblystation</span>
                        </a>
                    </li>
                }

                <li class="sidebar-item">
                    <a class="sidebar-link clickable" @onclick="() => ToggleStationFormular(true)">
                        <i class="lni lni-plus"></i>
                        <span>Add Station</span>
                    </a>
                </li>
            </ul>
        </aside>

        <!-- Sidebar ends-->
        <!-- Main Content -->
        <div class="main">
            <nav class="navbar navbar-expand">
                <button class="toggler-btn" @onclick="ToggleSidebar" type="button">
                    <i class="lni lni-menu-hamburger-1"></i>
                </button>
                <h5><span>Current Station: @(selectedStation != null ? selectedStation.assemblystation : "Please choose a station")</span></h5>
            </nav>
            <main class="p-3 pb-0 d-flex gap-3">

                <!-- Linke Spalte: Tools und Operationen -->
                <div class="tool-operation-panel p-5" style="width: 500px;">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h6>Tools and Operations</h6>
                        @if (selectedStation != null)
                        {
                            if (copiedTool != null)
                            {
                                <button class="btn btn-primary btn-sm" @onclick="() => InsertTool()">Insert Tool</button>
                            }
                            <button class="btn btn-primary btn-sm" @onclick="() => ToggleToolFormular(true)">+ Tool</button>
                        }

                    </div>

                    <div id="toolsList">
                        @if (selectedStation == null)
                        {
                            <p>Please choose a station.</p>
                        }
                        else if (!tools.Any())
                        {
                            <p>No tools found.</p>
                        }
                        else
                        {
                            @foreach (var tool in tools)
                            {
                                <div class="tool-section" data-tool-id="@tool.toolID">
                                    <div class="tool-header d-flex justify-content-between align-items-center">
                                        <span class="clickable" @onclick="() => { SelectTool(tool); ToggleToolFormular(false); }">@tool.toolShortname</span>
                                        <div>
                                            <button class="btn btn-secondary btn-sm mr-2" @onclick="@(() => CloneTool(tool))">copy</button>
                                            <button class="btn btn-secondary btn-sm mr-2" @onclick="() => { SelectTool(tool); ToggleOperationFormular(true);  }">+</button>


                                        </div>
                                    </div>
                                    <div class="operation-list">
                                        @foreach (var operation in allOperations.Where(op => op.toolID == tool.toolID))
                                        {
                                            <div class="operation-section d-flex justify-content-between align-items-center">
                                                <span class="clickable" @onclick="() => { SelectOperation(operation);  }">@operation.operationShortname</span>

                                            </div>
                                        }
                                    </div>
                                </div>
                            }
                        }
                    </div>
                </div>

                <!-- Rechte Spalte: Content -->
                <div class="content-panel flex-fill">
                    @if (showToolFormular && selectedTool != null)
                    {
                        <ToolFormular @ref="toolFormular" ReadOnly="toolReadOnly" SelectedTool="selectedTool" OnUpdated="ReloadTools" CurrentUser=@currentUser/>
                    }

                    @if (showOperationFormular && selectedOperation != null)
                    {
                        <OperationFormular @ref="operationFormular" ReadOnly="operationReadOnly" SelectedOperation="selectedOperation" OnUpdated="ReloadOperations" CurrentUser="@currentUser" />
                    }

                    @if (showStationFormular && selectedStation != null)
                    {
                        <StationFormular @ref="stationFormular" SelectedStation="selectedStation" OnUpdated="ReloadStations"  />
                    }
                </div>
            </main>
        </div>

    </div>
    @if (showPopup)
    {
        <SavePopup OnDismissChange="@HandleDismiss" OnSaveChange="@HandleSave"></SavePopup>
    }
</body>

@code {
    private readonly string currentUser = Guid.NewGuid().ToString();


    private StationFormular? stationFormular;
    private ToolFormular? toolFormular;
    private OperationFormular? operationFormular;


    private bool showPopup = false;

    private async Task HandleDismiss()
    {
        showPopup = false;
        DirtyManagerService.setClean();

        if (stationFormular != null)
            stationFormular.ResetStation();

        if (toolFormular != null)
            toolFormular.ResetTool();

        if (operationFormular != null)
            operationFormular.ResetOperation();

    }


    private async Task HandleSave()
    {
        showPopup = false;
        DirtyManagerService.setClean();

        if (stationFormular != null)
        {
            if(await stationFormular.ValidateData() == true)
            {
                stationFormular.UpdateStationAsync();
            }
            else
            {
                stationFormular.ResetStation();
            }
        }



        if (toolFormular != null)
        {
            if (await toolFormular.ValidateData() == true)
            {
                toolFormular.UpdateToolAsync();
            }
            else
            {
                toolFormular.ResetTool();
            }
        }


        if (operationFormular != null )
        {
            if (await operationFormular.ValidateData() == true)
            {
                operationFormular.UpdateOperationAsync();
            }
            else
            {
                operationFormular.ResetOperation();
            }
        }

    }
   

    #region SideBar
    private string BadgeColor = "#006700"; //needs to be implemented
    private string SidebarClass { get; set; } = string.Empty;
    private void ToggleSidebar()
    {
        if (SidebarClass.Contains("collapsed"))
            SidebarClass = string.Empty;
        else
            SidebarClass = "collapsed";
    }
    #endregion

    #region Line
    [Parameter]
    public string lineName { get; set; } = "";

    private Line? line;
    #endregion




    #region Stations
    private IEnumerable<Station> stations = Enumerable.Empty<Station>();
    private Station? selectedStation;





    private async Task SelectStation(Station station)
    {


        if (DirtyManagerService.IsDirty().Result == true)
        {
            showPopup = true;
        }
        else
        {
            selectedStation = new Station
                {
                    stationID = station.stationID,
                    lineID = station.lineID,
                    stationTypeID = station.stationTypeID,
                    assemblystation = station.assemblystation,
                    stationName = station.stationName

                };
            selectedTool = new Tool
                {
                    stationID = selectedStation.stationID,  // Setze stationID
                    toolTypeID = 1, 
                    isLocked = false// Setze den Foreign Key auf 1 (oder einen anderen Wert je nach Bedarf)
                };  // Setze das ausgewählte Tool zurück


            selectedOperation = new Operation
                {
                    toolID = selectedTool.toolID,  // Setze die toolID
                    decisionClassID = 1,           // Setze den Foreign Key auf 1
                    savingClassID = 1,             // Setze den Foreign Key auf 1
                    generationClassID = 1,         // Setze den Foreign Key auf 1
                    verificationClassID = 1,       // Setze den Foreign Key auf 1
                    qGateID = 1 ,
                    isLocked = false,
                // Setze den Foreign Key auf 1
                };  // Setze die ausgewählte Operation zurück;  // Setze die ausgewählte Operation zurück

            tools = await Fassade.GetToolsFromStation(station.stationID);

            StateHasChanged();
        }

    }
    #endregion



    #region Tools
    private IEnumerable<Tool> tools = Enumerable.Empty<Tool>();
    private Tool? selectedTool;
    private bool toolReadOnly = false;


    private async Task SelectTool(Tool tool)
    {
        if (DirtyManagerService.IsDirty().Result == true)
        {
            showPopup = true;
        }
        else
        {
            if(selectedTool != null)
            {
                if (selectedTool.lockedBy == currentUser && selectedTool.toolID != tool.toolID)
                {
                    selectedTool.isLocked = false;
                    selectedTool.lockedBy = null;
                    await Fassade.UpdateTool(selectedTool);
                    await SignalRService.SendMessageToServer("ToolChanged");
                    await SignalRService.SendMessageToServer("ToolUnlocked;" + selectedTool.toolID.ToString());

                }
            }

            selectedTool = tool;
            if(selectedTool.isLocked == false || tool.lockedBy == currentUser)
            {
                toolReadOnly = false;

            }
            else
            {
                toolReadOnly = true;
            }

            if(selectedOperation != null && selectedOperation.isLocked == true && selectedOperation.lockedBy == currentUser)
            {
                selectedOperation.isLocked = false;
                selectedOperation.lockedBy = null;
                await Fassade.UpdateOperation(selectedOperation);
                await SignalRService.SendMessageToServer("OperationChanged");
                await SignalRService.SendMessageToServer("OperationUnlocked;" + selectedOperation.operationID.ToString());
            }

            selectedOperation = new Operation
                {
                    toolID = selectedTool.toolID,  
                    decisionClassID = 1,           
                    savingClassID = 1,             
                    generationClassID = 1,         
                    verificationClassID = 1,      
                    qGateID = 1,   
                    isLocked = false,
                };  

            tools = await Fassade.GetToolsFromStation(selectedStation.stationID);  

            StateHasChanged();  // Aktualisiere den UI-Status
        }

    }

    private void ToggleToolFormular(bool isNewTool)
    {
        if (isNewTool)
        {
            selectedTool = new Tool
                {
                    stationID = selectedStation.stationID,  // Setze stationID
                    toolTypeID = 0,   
                    toolClassID = 0,
                    isLocked = false// Setze den Foreign Key auf 1 (oder einen anderen Wert je nach Bedarf)
                };
        }
        showToolFormular = true;
        showOperationFormular = false;
        showStationFormular = false;

        StateHasChanged();  // Aktualisiere den UI-Status

    }

    #endregion

    #region Operation
    private IEnumerable<Operation> operations = Enumerable.Empty<Operation>();
    private IEnumerable<Operation> allOperations;
    private Operation? selectedOperation;
    private bool operationReadOnly = false;

    private async Task SelectOperation(Operation operation)
    {
        if (DirtyManagerService.IsDirty().Result == true)
        {
            showPopup = true;
        }
        else
        {

            if(selectedOperation != null)
            {
                if (selectedOperation.lockedBy == currentUser && selectedOperation.operationID != operation.operationID)
                {
                    selectedOperation.isLocked = false;
                    selectedOperation.lockedBy = null;
                    await Fassade.UpdateOperation(selectedOperation);
                    await SignalRService.SendMessageToServer("OperationChanged");
                    await SignalRService.SendMessageToServer("OperationUnlocked;" + selectedOperation.operationID.ToString());

                }
            }


            selectedOperation = operation;
            if (selectedTool.isLocked == true && selectedTool.lockedBy == currentUser)
            {
                selectedTool.isLocked = false;
                selectedTool.lockedBy = null;
                await Fassade.UpdateTool(selectedTool);
                await SignalRService.SendMessageToServer("ToolChanged");
                await SignalRService.SendMessageToServer("ToolUnlocked;" + selectedTool.toolID.ToString());
            }
 
            selectedTool = await Fassade.GetTool(selectedOperation.toolID);

            if(selectedOperation.isLocked == false || operation.lockedBy == currentUser)
            {

                operationReadOnly = false;

            }
            else
            {
                operationReadOnly = true;
            }



            showOperationFormular = true;
            showToolFormular = false;
            showStationFormular = false;


            StateHasChanged();  // Aktualisiere den UI-Status
        }

    }

    private void ToggleOperationFormular(bool isNewOperation)
    {

        if (isNewOperation)
        {
            selectedOperation = new Operation
                {
                    toolID = selectedTool.toolID,  // Setze die toolID
                    decisionClassID = 1,           // Setze den Foreign Key auf 1
                    savingClassID = 1,             // Setze den Foreign Key auf 1
                    generationClassID = 1,         // Setze den Foreign Key auf 1
                    verificationClassID = 1,       // Setze den Foreign Key auf 1
                    qGateID = 1,
                    isLocked = false,// Setze den Foreign Key auf 1
                };
        }
        showOperationFormular = true;
        showToolFormular = false;
        showStationFormular = false;

        StateHasChanged();  // Aktualisiere den UI-Status
    }

    #endregion

    /*
    #region DragAndDrop

    private List<Station> displayedStations = new List<Station>();
    private Station draggedItem;
    private string draggedItemClass = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        // Your existing initialization code

        if (line != null)
        {
            var stationsFromDb = await Fassade.GetStationsFromLine(line.lineID);
            displayedStations = stationsFromDb.ToList();
        }
    }

    private void HandleDragStart(Station station)
    {
        draggedItem = station;
        draggedItemClass = "dragging";
    }

    private void HandleDragOver(DragEventArgs e)
    {
        e.PreventDefault(); // Necessary to allow dropping
    }

    private void HandleDragEnd()
    {
        draggedItemClass = string.Empty;
    }

    private void HandleDrop(DragEventArgs e)
    {
        e.PreventDefault();

        // Get the drop target
        var dropTarget = e.CurrentTarget as ElementReference;

        // In a real implementation, you'd want to find the exact position
        // For simplicity, we'll just move the dragged item to the end
        if (draggedItem != null)
        {
            displayedStations.Remove(draggedItem);
            displayedStations.Add(draggedItem);
            StateHasChanged();
        }
    }
    #endregion

    
  
private bool dragInitialized = false;

protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
            await JS.InvokeVoidAsync("setupDragDrop");

            // Setup event listener for when drag ends to update order
            await JS.InvokeVoidAsync("eval",
                    @"document.getElementById('stationsContainer').addEventListener('dragend', async () => {
                    const stations = Array.from(document.querySelectorAll('.draggable'));
                    const stationOrder = stations.map(station => parseInt(station.getAttribute('data-station-id')));
                    await DotNet.invokeMethodAsync('YourAssemblyName', 'UpdateStationOrder', stationOrder);
                });");
    }
}
    [JSInvokable]
    public async Task UpdateStationOrder(List<int> newOrder)
    {
        try
        {
            // Update the station order in your database
            await Fassade.UpdateStationOrder(line.lineID, newOrder);

            // Refresh the stations list
            stations = await Fassade.GetStationsFromLine(line.lineID);

            // Notify other clients of the change
            await SignalRService.SendMessageToServer("StationChanged");

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating station order: {ex.Message}");
        }
    }

    // Method to reinitialize drag and drop when stations change
    private async Task ReloadStations()
    {
        if (line != null)
        {
            stations = await Fassade.GetStationsFromLine(line.lineID);
            StateHasChanged();

            // Wait for DOM update then reinitialize drag and drop
            await Task.Delay(100);
            dragInitialized = false;
            await InitializeDragAndDropAsync();
        }
    }


private async Task InitializeDragAndDropAsync()
{
    try
    {
        // Add delay to ensure DOM is fully rendered
        await Task.Delay(300);

        // Check if we have stations to make draggable
        if (stations != null && stations.Any())
        {
            Console.WriteLine("Initializing drag and drop...");

            // Try to initialize drag and drop
            var result = await JS.InvokeAsync<bool>("initializeDragAndDropSafe", ".draggable");
            
            if (result)
            {
                dragInitialized = true;
                Console.WriteLine("Drag and drop initialized successfully");
            }
            else
            {
                Console.WriteLine("Failed to initialize drag and drop");
            }
        }
        else
        {
            Console.WriteLine("No stations available for drag and drop - will retry after station loading");
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error initializing drag and drop: {ex.Message}");
    }
}

*/







    protected override async Task OnInitializedAsync()
    {
        LifecycleService.OnAppClosing += HandleAppClosingAsync;
        SignalRService.RegisterResponseHandler(async (string msg) =>
    {
        await InvokeAsync(async () =>
        {

            if (msg.StartsWith("OperationUnlocked"))
            {




                var operationID = int.Parse(msg.Split(';')[1]);
                if (selectedOperation?.operationID == operationID)
                {
                   
                                                                                                                    operationReadOnly = false;
                }
            }
            else if (msg.StartsWith("OperationLocked"))
            {
                var operationID = int.Parse(msg.Split(';')[1]);
                if (selectedOperation?.lockedBy != currentUser)
                {

                    operationReadOnly = true;
                }
            }

            if (msg.StartsWith("ToolUnlocked"))
            {




                var toolID = int.Parse(msg.Split(';')[1]);
                if (selectedTool?.toolID == toolID)
                {
                    /*selectedTool.isLocked = true;
                    selectedTool.lockedBy = currentUser;
                    await Fassade.UpdateTool(selectedTool);
                    await SignalRService.SendMessageToServer("ToolChanged");*/
                                                                                                                    toolReadOnly = false;
                }
            }
            else if (msg.StartsWith("ToolLocked"))
            {
                var toolID = int.Parse(msg.Split(';')[1]);
                if (selectedTool?.lockedBy != currentUser)
                {

                    toolReadOnly = true;
                }
            }
            else if (msg.StartsWith("ToolClassChanged"))
            {
                var id = int.Parse(msg.Split(';')[1]);
                if(selectedTool != null)
                {
                    var operations = await Fassade.GetOperationsFromTool(selectedTool.toolID);
                }
               
                if(operations != null)
                {
                    foreach (var op in operations)
                    {
                        op.decisionClassID = 1;
                        op.verificationClassID = 0;
                        op.savingClassID = 0;
                        op.generationClassID = 0;
                        await Fassade.UpdateOperation(op);
                    }
                    await SignalRService.SendMessageToServer("OperationChanged");
                }
                
            }
            else
            {
                switch (msg)
                {
                    case "StationChanged":
                        if (line != null)
                        {
                            stations = await Fassade.GetStationsFromLine(line.lineID);
                            if (selectedStation != null)
                            {
                                // Hole die aktualisierte Station aus der Datenbank
                                selectedStation = stations.FirstOrDefault(s => s.stationID == selectedStation.stationID);
                            }

                        }
                        break;
                    case "ToolChanged":
                        if (selectedStation != null)
                        {
                            tools = await Fassade.GetToolsFromStation(selectedStation.stationID);
                            if (selectedTool != null)
                            {
                                // Aktualisiere das ausgewählte Tool aus der neuen Liste
                                selectedTool = tools.FirstOrDefault(t => t.toolID == selectedTool.toolID);
                            }



                        }
                        break;
                    case "OperationChanged":
                        if (selectedTool != null)
                        {
                            operations = await Fassade.GetOperationsFromTool(selectedTool.toolID);
                            if (selectedOperation != null)
                            {
                                // Aktualisiere die ausgewählte Operation aus der neuen Liste
                                selectedOperation = operations.FirstOrDefault(o => o.operationID == selectedOperation.operationID);
                            }
                            allOperations = await Fassade.GetAllOperations();
                        }
                        break;


                }


            }

            StateHasChanged();
        });
    });




        // 2) Starte die Verbindung
        await SignalRService.StartConnectionAsync();








        line = await Fassade.GetLineByName(lineName);

        if (line != null)
        {
            stations = await Fassade.GetStationsFromLine(line.lineID);
            if (stations != null)
            {
                allOperations = await Fassade.GetAllOperations();
            }
        }
    }

    private bool showToolFormular = false;
    private bool showOperationFormular = false;
    private bool showStationFormular = false;

    private void ToggleStationFormular(bool isNewStation)
    {
        if (isNewStation)
        {
            selectedStation = new Station
                {
                    lineID = line.lineID,
                    stationTypeID = 1
                };
            selectedTool = null;
            selectedOperation = null;
            tools = Enumerable.Empty<Tool>();
            allOperations = Enumerable.Empty<Operation>();
        }
        showStationFormular = true;
        showToolFormular = false;
        showOperationFormular = false;



    }


    /*
    private async Task ReloadStations()
    {
        if (line != null)
        {
            stations = await Fassade.GetStationsFromLine(line.lineID);
            StateHasChanged();
        }
    }*/

    private async Task ReloadTools()
    {
        if (line != null && selectedStation != null)
        {
            tools = await Fassade.GetToolsFromStation(selectedStation.stationID);
            StateHasChanged();
        }
    }

    private async Task ReloadOperations()
    {
        if (line != null && selectedStation != null && selectedTool != null)
        {
            operations = await Fassade.GetOperationsFromTool(selectedTool.toolID);
            allOperations = await Fassade.GetAllOperations();
            StateHasChanged();
        }
    }

    #region Clone
    private Tool? copiedTool;
    private Operation? copiedOperation;
    public void CloneTool(Tool copied)
    {

        copiedTool = Fassade.Clone(copied);

    }

    public void CloneOperation(Operation copied)
    {
        copiedOperation = Fassade.Clone(copied);
    }

    public void InsertTool()
    {
        selectedTool = copiedTool;
        selectedTool.stationID = selectedStation.stationID;
        copiedTool = null;
        ToggleToolFormular(false);
    }

    public void InsertOperation()
    {
        selectedOperation = copiedOperation;
        selectedOperation.toolID = selectedTool.toolID;
        copiedOperation = null;
        ToggleOperationFormular(false);
    }
    #endregion


    private async Task HandleAppClosingAsync()
    {
        // Hier dein UnlockTool() aufrufen oder Warnung anzeigen
        await UnlockTool(new Tool
            {
                stationID = 1,
                toolTypeID = 1,
                isLocked = false
            });
    }

    public async Task UnlockTool(Tool tool)
    {

        if (selectedTool != null)
        {
            if (selectedTool.lockedBy == currentUser && selectedTool.toolID != tool.toolID)
            {
                selectedTool.isLocked = false;
                selectedTool.lockedBy = null;
                await Fassade.UpdateTool(selectedTool);
                await SignalRService.SendMessageToServer("ToolChanged");
                await SignalRService.SendMessageToServer("ToolUnlocked;" + selectedTool.toolID.ToString());


                
            }
        }
    }
    
 }
